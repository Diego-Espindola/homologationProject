import time
import argparse
import threading
import queue
from ExecucaoPrincipal import processar_matriculas, processar_eventos, processar_cargos_esfinge, processar_enderecos, processar_dependentes
from AppTKinter import App
#import traceback
import os
import sys

"""
# Caminho para o Python dentro da venv
script_dir = os.path.dirname(os.path.abspath(__file__))
venv_python = os.path.join(script_dir, 'venv', 'Scripts', 'python.exe')

# Adicione o caminho ao PATH
os.environ['PATH'] = os.path.dirname(venv_python) + os.pathsep + os.environ['PATH']

# Re-execute o script com o Python da venv, se não estiver sendo executado por ele
if sys.executable != venv_python:
    print('Interpretador errado, script será reiniciado com o correto em 5s', sys.executable, venv_python)
    time.sleep(5)
    os.execv(venv_python, [venv_python] + sys.argv)
"""

def main(app):

    while not app.iniciar_homologacao:
        pass

    pessoas_fisicas_queue = queue.Queue()
    matriculas_pessoa_queue = queue.Queue()
    
    # Processamento de matrículas
    thread_matriculas = threading.Thread(target=processar_matriculas, args=(app, app.progress_bar_matriculas, app.label_status_matriculas, pessoas_fisicas_queue, matriculas_pessoa_queue))
    thread_matriculas.start()

    # Processamento de eventos
    thread_eventos = threading.Thread(target=processar_eventos, args=(app, app.progress_bar_eventos, app.label_status_eventos))
    thread_eventos.start()

    # Processamento de cargos
    thread_cargos_esfinge = threading.Thread(target=processar_cargos_esfinge, args=(app, app.progress_bar_cargos, app.label_status_cargos))
    thread_cargos_esfinge.start()

    # Continuar o código somente após a thread de matrículas finalizar
    thread_matriculas.join() 

    thread_dependentes = threading.Thread(target=processar_dependentes, args=(app, matriculas_pessoa_queue.get(), app.progress_bar_dependentes, app.label_status_dependentes))
    thread_dependentes.start()

    thread_enderecos = threading.Thread(target=processar_enderecos, args=(app, pessoas_fisicas_queue.get(), app.progress_bar_enderecos, app.label_status_enderecos))
    thread_enderecos.start()

    # Para só finalizar a main() após todas as threads terminarem e então encaminhar o e-mail.
    while (
        thread_matriculas.is_alive() or 
        thread_eventos.is_alive() or 
        thread_cargos_esfinge.is_alive() or 
        thread_dependentes.is_alive() or 
        thread_enderecos.is_alive()
    ):
        pass # Aguarda até que todas as threads finalizem

    app.terminou_homologacao = True



if __name__ == "__main__":
    parser = argparse.ArgumentParser(description='Process some integers.')
    parser.add_argument('--email_remetente', type=str, help='Email utilizado para envio dos erros')
    parser.add_argument('--email_passwd', type=str, help='Senha do email')
    args = parser.parse_args() # Variáveis recebidas ao rodar o código

    app = App(email_remetente=args.email_remetente, email_passwd=args.email_passwd)
    thread_main = threading.Thread(target=main, args=(app,))
    thread_main.start() # Iniciar o processamento em uma thread separada para que o TK fique em mainloop

    threading.Thread(target=app.verificar_threads_envio_email, args=(thread_main,)).start() # Enviar email com o resultado
    app.mainloop()