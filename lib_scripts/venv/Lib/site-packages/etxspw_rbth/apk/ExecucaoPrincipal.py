import pandas as pd
import time
import io
import os
from os.path import join, dirname
from cloud_busca import buscar_matriculas, buscar_eventos, buscar_cargos, buscar_dependentes
from Gerenciador_erros import checar_discrepancias_matricula, checar_discrepancias_evento, checar_discrepancias_endereco, checar_discrepancias_cargo, checar_discrepancias_dependentes, erro_sem_id
from Gerenciador_erros import inicializar_erros_matriculas, inicializar_erros_eventos, inicializar_erros_enderecos, inicializar_erros_cargos, inicializar_erros_dependentes
from consulta_banco_dados import consulta_matriculas, consulta_eventos, consulta_enderecos, consulta_cargo_tce, consulta_dependentes


class ExecucaoPrincipal:
    """
    #TODO
    """
    def __init__(self, app, inicializar_erros):
        self.odbc = app.odbc
        self.token = app.token
        self.entidades = app.entidades
        self.tipos_de_erros = inicializar_erros
        self.diretorio_geral = self.subir_diretorios(7, dirname(__file__))

    @staticmethod
    def subir_diretorios(quantidade, diretorio):
        for i in range(0, quantidade):
            diretorio = dirname(diretorio)
        return diretorio

    def inserir_erro(self, tipo_erro, gerenciadorErros, desktop, cloud):
        self.tipos_de_erros[tipo_erro].append((gerenciadorErros.identificador_desk, gerenciadorErros.identificador_cloud, gerenciadorErros.descricao, desktop, cloud))

    def  gerar_erros(self, colunas, nome_arquivo):
        nome_arquivo = f"{nome_arquivo}_{self.odbc}"
        caminho_arquivo = join(self.diretorio_geral, 'retornos', f"{nome_arquivo}.xlsx")
        os.makedirs(dirname(caminho_arquivo), exist_ok=True) # Garante que o diretório 'retornos' exista
        planilhas = {}
        for tipo_erro, ocorrencias in self.tipos_de_erros.items():
            if ocorrencias:
                df = pd.DataFrame(ocorrencias, columns=colunas)
                nome_planilha = f"{tipo_erro[:31]}"
                planilhas[nome_planilha] = df
                print(f"\nErro: {tipo_erro} - {len(ocorrencias)} inconsistências")
        if planilhas:
            with pd.ExcelWriter(caminho_arquivo, engine='xlsxwriter') as writer:
                for nome_planilha, df in planilhas.items():
                    df.to_excel(writer, sheet_name=nome_planilha, index=False)
                print(f"Arquivo gerado - {caminho_arquivo}")
            
            # Para enviar o e-mail
            buffer_xlsx = io.BytesIO()
            with pd.ExcelWriter(buffer_xlsx, engine='xlsxwriter') as writer:
                for nome_planilha, df in planilhas.items():
                    df.to_excel(writer, sheet_name=nome_planilha, index=False)
            buffer_xlsx.seek(0)  # Voltar para o início do buffer para leitura
            return {f"{nome_arquivo}.xlsx":buffer_xlsx}
        else:
            return {}


def processar_matriculas(app, progress_bar, label, pessoas_fisicas_queue, matriculas_pessoa_queue):
    execucaoPrincipal = ExecucaoPrincipal(app, inicializar_erros_matriculas)

    label.config(text="Iniciando a busca no banco de dados ...")
    df_desktop_matricula = consulta_matriculas(execucaoPrincipal)
    total_matriculas = len(df_desktop_matricula)
    label.config(text=f"Encontrados {total_matriculas} matrículas, iniciando buscas no Cloud")
    time.sleep(1)
    contagem_buscas = 0

    pessoas_fisicas_encontradas = []
    matriculas_pessoas_encontradas = {}
    id_set = []
    for index, rows in df_desktop_matricula.iterrows():
        label.config(text=f"Validando matrícula {index+1} de {total_matriculas}")
        if rows.id is None:
            erro_sem_id(execucaoPrincipal, rows.matricula, "MATRICULA_NAO_ENCONTRADA")
            continue
        try:
            buscaMatricula = buscar_matriculas(id_matricula=rows.id, token_=execucaoPrincipal.token)
            checar_discrepancias_matricula(rows=rows, buscaMatricula=buscaMatricula, execucaoPrincipal=execucaoPrincipal)
            contagem_buscas += 1
            progresso = contagem_buscas / total_matriculas * 100
            progress_bar['value'] = progresso
            app.update_idletasks()  # Atualiza a interface gráfica
            #break

            # Guarda a pessoa para utilizar na validação de endereço
            pessoa_atual = {"i_pessoas":rows.i_pessoas,
                            "historico_pessoa":buscaMatricula.historico_pessoa}
            if rows.i_pessoas not in id_set:
                pessoas_fisicas_encontradas.append(pessoa_atual)
                id_set.append(rows.i_pessoas)
            
            # Liga os funcionários à pessoa para validação de dependentes
            id_pessoa = buscaMatricula.historico_pessoa.get("id")
            if id_pessoa is not None:
                if id_pessoa in matriculas_pessoas_encontradas:
                    matriculas_pessoas_encontradas[id_pessoa] += f",{rows.matricula}"
                else:
                    matriculas_pessoas_encontradas[id_pessoa] = f"{rows.matricula}"
        except Exception as e:
            print(f"Erro ao processar matrícula: {e}")
    print(f"Banco:{execucaoPrincipal.odbc}. Validação das matrículas finalizada! Total de buscas realizadas: {contagem_buscas}")

    retorno_dataframe = execucaoPrincipal.gerar_erros(['matricula_desk', 'matricula_cloud', 'id_gerado', 'desktop', 'cloud'], 'erros_matriculas')
    app.dicionario_retorno_dataframe.update(retorno_dataframe)
    pessoas_fisicas_queue.put(pessoas_fisicas_encontradas)
    matriculas_pessoa_queue.put(matriculas_pessoas_encontradas)
    label.config(text=f"Validação Finalizada, Total de buscas realizadas: {contagem_buscas}")


def processar_eventos(app, progress_bar, label):
    execucaoPrincipal = ExecucaoPrincipal(app, inicializar_erros_eventos)
    label.config(text="Iniciando a busca no banco de dados ...")
    df_desktop_evento = consulta_eventos(execucaoPrincipal)
    total_eventos = len(df_desktop_evento)
    label.config(text=f"Encontrados {total_eventos} eventos, iniciando buscas no Cloud")
    time.sleep(1.5)

    contagem_buscas = 0
    for index, rows in df_desktop_evento.iterrows():
        label.config(text=f"Validando evento {index+1} de {total_eventos}")
        try:
            buscaEvento = buscar_eventos(id_evento=rows.id, token_=execucaoPrincipal.token)
            checar_discrepancias_evento(rows=rows, buscaEvento=buscaEvento, execucaoPrincipal=execucaoPrincipal)
            time.sleep(0.1)
            contagem_buscas += 1
            progresso = contagem_buscas / total_eventos * 100
            progress_bar['value'] = progresso
            app.update_idletasks()  # Atualiza a interface gráfica
            #break
        except Exception as e:
            print(f"Erro ao processar evento: {e}")

    print(f"Banco:{execucaoPrincipal.odbc}. Validação dos eventos finalizada! Total de buscas realizadas: {contagem_buscas}")
    label.config(text=f"Validação Finalizada, Total de buscas realizadas: {contagem_buscas}")
    label.configure(style="Success.TLabel")

    retorno_dataframe = execucaoPrincipal.gerar_erros(['evento_desk', 'evento_cloud', 'id_gerado', 'desktop', 'cloud'], 'erros_eventos')
    app.dicionario_retorno_dataframe.update(retorno_dataframe)


def processar_enderecos(app, pessoas_fisicas, progress_bar, label):
    execucaoPrincipal = ExecucaoPrincipal(app, inicializar_erros_enderecos)

    label.config(text="Iniciando a busca no banco de dados ...")
    total_pessoas = len(pessoas_fisicas)
    label.config(text=f"Encontrados {total_pessoas} pessoas, iniciando buscas no Cloud")
    time.sleep(1.5)
    
    contagem_buscas = 0
    for pessoa in pessoas_fisicas:
        label.config(text=f"Validando pessoa {contagem_buscas+1} de {total_pessoas}")
        execucaoPrincipal.i_pessoas = pessoa['i_pessoas']
        execucaoPrincipal.nome = pessoa['historico_pessoa']['nome']
        execucaoPrincipal.id = pessoa['historico_pessoa']['id']

        df_desktop_endereco = consulta_enderecos(execucaoPrincipal)
        df_cloud_endereco = pd.json_normalize(pessoa['historico_pessoa']['enderecos'])
        checar_discrepancias_endereco(desktop_data=df_desktop_endereco, cloud_data=df_cloud_endereco, execucaoPrincipal=execucaoPrincipal)
        contagem_buscas += 1
        progresso = contagem_buscas / total_pessoas * 100
        progress_bar['value'] = progresso
        app.update_idletasks()  # Atualiza a interface gráfica

    print(f"Banco:{execucaoPrincipal.odbc}. Validação dos enderecos finalizada! Total de buscas realizadas: {contagem_buscas}")
    retorno_dataframe = execucaoPrincipal.gerar_erros(['pessoa_desk', 'pessoa_cloud', 'id_gerado', 'desktop', 'cloud'], 'erros_enderecos')
    app.dicionario_retorno_dataframe.update(retorno_dataframe)
    label.config(text=f"Validação Finalizada, Total de buscas realizadas: {contagem_buscas}")


def processar_cargos_esfinge(app, progress_bar, label):
    execucaoPrincipal = ExecucaoPrincipal(app, inicializar_erros_cargos)
    label.config(text="Iniciando a busca no banco de dados ...")
    df_cargos_desk = consulta_cargo_tce(execucaoPrincipal)
    total_cargos = len(df_cargos_desk)
    label.config(text=f"Encontrados {total_cargos} cargos, iniciando buscas no Cloud")
    time.sleep(1.5)
    contagem_buscas = 0
    for index, rows in df_cargos_desk.iterrows():
        label.config(text=f"Validando cargo {index+1} de {total_cargos}")
        try:
            buscaCargo = buscar_cargos(rows.id_cargo, execucaoPrincipal.token)
            checar_discrepancias_cargo(rows, buscaCargo, execucaoPrincipal)
            contagem_buscas += 1
            progresso = contagem_buscas / total_cargos * 100
            progress_bar['value'] = progresso
            app.update_idletasks()  # Atualiza a interface gráfica
            #break
        except Exception as e:
            print(f"Erro ao processar cargo_esfinge: {e}")
            print(buscaCargo.ato)
            exit()
    print(f"Banco:{execucaoPrincipal.odbc}. Validação dos cargos TCE finalizada! Total de buscas realizadas: {contagem_buscas}")
    retorno_dataframe = execucaoPrincipal.gerar_erros(['codigo_cargo_desk', 'id_cargo_cloud', 'descricao', 'desktop', 'cloud'], 'erros_cargos_tce')
    app.dicionario_retorno_dataframe.update(retorno_dataframe)
    label.config(text=f"Validação Finalizada, Total de buscas realizadas: {contagem_buscas}")
        

def processar_dependentes(app, dicionario_funcionarios, progress_bar, label):
    """
    Ele faz uma busca no desktop utilizando as matrículas ativas das pessoas encontradas no processamento de matrículas (dicionario_funcionarios)

    dicionario_funcionarios: É um dicionário que usa como chave o id da pessoa, no valor estão os funcionários ligados à essa pessoa
    app: Janela TK

    Cria as variáveis matriculas e id_pessoa_responsavel_cloud para serem utilizados nas buscas e também apresentado no Excel de erros
    Dentro do gerenciador de erros, a cada dependente ele salva o nome da pessoa para aparecer na terceira coluna 'descricao'
    """
    execucaoPrincipal = ExecucaoPrincipal(app, inicializar_erros_dependentes)

    label.config(text="Iniciando a busca no banco de dados ...")
    total_pessoas = len(dicionario_funcionarios)

    label.config(text=f"Encontrados {total_pessoas} responsáveis ativos, iniciando buscas no Cloud")
    dicionario_dependentes_func = buscar_dependentes( list(dicionario_funcionarios.keys()), execucaoPrincipal.token)
    
    contagem_buscas = 0
    for id_pessoa in dicionario_funcionarios:
        label.config(text=f"Validando pessoa {contagem_buscas+1} de {total_pessoas}")
        execucaoPrincipal.matriculas = dicionario_funcionarios[id_pessoa]
        execucaoPrincipal.id_pessoa_responsavel_cloud = id_pessoa
        
        df_desktop = consulta_dependentes(execucaoPrincipal)
        df_cloud = pd.json_normalize(dicionario_dependentes_func.get(id_pessoa, {}))
        if df_cloud.empty:
            df_cloud = pd.DataFrame(columns=df_desktop.columns)
        
        checar_discrepancias_dependentes(desktop_data=df_desktop, cloud_data=df_cloud, execucaoPrincipal=execucaoPrincipal)
        
        contagem_buscas += 1
        progresso = contagem_buscas / total_pessoas * 100
        progress_bar['value'] = progresso
        app.update_idletasks()  # Atualiza a interface gráfica

    print(f"Banco:{execucaoPrincipal.odbc}. Validação dos dependentes finalizada! Total de buscas realizadas: {contagem_buscas}")
    label.config(text=f"Validação Finalizada, Total de buscas realizadas: {contagem_buscas}")
    label.configure(style="Success.TLabel")
    
    retorno_dataframe = execucaoPrincipal.gerar_erros(['matriculas_pessoa_responsavel_desk', 'id_pessoa_responsavel_cloud', 'nome_dependente', 'dado_desktop', 'dado_cloud'], 'erros_dependentes_func')
    app.dicionario_retorno_dataframe.update(retorno_dataframe)
    return
